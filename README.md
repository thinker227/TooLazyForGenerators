# Too Lazy for Generators

<sup>[Head directly to the samples!](#show-me-some-samples)</sup>

Are you too lazy to write good and efficient [source generators](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview)? Do you want a simple and lightweight way to generate C# source code? This library mightâ„¢ be for you!

Too Lazy for Generators is a library meant to provide a simple and lightweight way to generate C# source code. The library acts as a thin layer on top of the [Roslyn APIs](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk) which abstracts the process of initiating and applying syntax additions, but which stills allows for full access to all the available compiler APIs. As the library does not attempt to hide the actual Roslyn APIs, it is *heavily* recommended that you are either already familiar with said APIs, or that you [read up on them](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/compiler-api-model).

It is important to note that this library follows the design principles of source generators and is **purely additive**, meaning you cannot modify existing source code, only add new C# source files. *Unlike* source generators, however, Too Lazy for Generators gives you access to the full [Roslyn workspace APIs](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-workspace) which allows you to access APIs which are unavailable to or not recommended for source generators.

A major difference to source generators is that Too Lazy for Generators generators are meant to run as either an on-command action or as a pre-compile step. For this reason, they do not have to conform to the high-efficieny standards of source generators, and you can freely use APIs which are deemed slower, less performant, or more existent than their recommended source generator counterparts. Obviously it's still up to you to decide how many of these APIs you choose to use depending on how fast you want the generation to be. If running as a pre-compile step, for instance, you may want to avoid slower APIs such as [`NormalizeWhitespace`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntaxextensions.normalizewhitespace) or `ILazyGeneratorBuilder.TargetingProjectWithName`.

## Show me some samples!!!

The simplest possible sample consists of a regular .NET 7 console app with (only!) two source files:

<sub>[Program.cs](./sample/TooLazyForGenerators.Sample.Generator/Program.cs)</sub>
```cs
using TooLazyForGenerators;

var builder = new LazyGeneratorBuilder();
// Target the project TooLazyForGenerators.Sample.
await builder.TargetingProjectWithName("TooLazyForGenerators.Sample");
// Use all outputs from the current assembly.
builder.WithOutputsFromAssembly();

// Build the generator and run it.
using var output = await builder.Build().Run();
// Write the output to disk and return a status code.
return output.WriteAndReturn();
```
<sub>[Output.cs](./sample/TooLazyForGenerators.Sample.Generator/Output.cs)</sub>
```cs
namespace TooLazyForGenerators.Sample.Generator;

public sealed class Output : ISourceOutput
{
    public Task GetSource(ISourceOutputContext ctx)
    {
        ctx.AddSource("""
        /// <auto-generated />

        using System;

        public static class Generated
        {
            public static void Hello() =>
                Console.WriteLine("Hello, World!"); 
        }
        """, "Generated.g.cs");

        return Task.CompletedTask;
    }
}
```

On startup, a new `LazyGeneratorBuilder` is created and configured with some basic defaults. The builder is then built into a `LazyGenerator` and run asynchronously. Lastly, the output of the generator is written to disk and a status code is returned based on whether the generator reported any errors. The structure of creating a builder, configuring it, then building and running it is heavily inspired by the minimal startup API of [ASP.NET Core](https://github.com/dotnet/aspnetcore).

A target project is registered in the builder using `ILazyGeneratorBuilder.TargetingProject(FileInfo)` taking the `.csproj` file of the project as its argument, its overload taking a string instead of a `FileInfo`, or `ILazyGeneratorBuilder.TargetingProjectWithName(string)` which attempts to search for a solution file in a parent directory and target a project in the solution with the supplied name (this method is very slow but provides easily the best API).

A generator output is defined as a class implementing `ISourceOutput`. Each output has access to an `ISourceOutputContext` which provides a variety of properties and methods to read projects and produce new source files and errors. The output has to be registered in the builder using `ILazyGeneratorBuilder.WithOutput(Type)`, its generic variant `ILazyGeneratorBuilder.WithOutput<T>()`, or `ILazyGeneratorBuilder.WithOutputsFromAssembly([Assembly?])` which takes an optional assembly (otherwise using the calling assembly) and registers all types implementing `ISourceOutput` in it through reflection.

## Additional goodies

### Middleware, oh my!

Too Lazy for Generators supports a form of [middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware) called "pipelines". If you're familiar with ASP.NET Core then this will look familiar.

```cs
builder.Using((ctx, next) =>
{
    Console.WriteLine("Hewwo from the pipeline!");
    return next(ctx);
});
```

A pipeline step a defined using the `IPipelineBuilder.Using(PipelineStep)` method, which takes a delegate taking a pipeline context and a next step as its parameters. The pipeline context is mutable and will be passed along to the next step of the pipeline, providing ways to configure each call to a generator output. The `next` parameter is a delegate taking the pipeline context which when calling will proceed to the next step of the pipeline (or just run the generator output if it's the final pipeline step). You can also choose to not call `next`, which will just not proceed with the pipeline.

Alike ASP.NET Core middleware, the order that pipeline steps are registered in determines in what order they will be run.

```cs
builder.Using((ctx, next) =>
{
    // This will be run first
    Console.WriteLine("step A");
    return next(ctx);
});

builder.Using((ctx, next) =>
{
    // This will be run second
    Console.WriteLine("step B");
    return next(ctx);
});
```

### Dependency injection, dependency injection for *everyone!*

Too Lazy for Generators supports your standard form of dependency injection using [Microsoft.Extensions.DependencyInjection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection).

> **Note**
> Using dependency injection in its fullest form requires `IPipelineBuilder.UsingDependencyInjection()` to be called during configuration.

```cs
builder.UsingDependencyInjection();

builder.Services.AddScoped(new Config(98, "abc"));

record Config(int A, string B);
```
```cs
public sealed class Output : ISourceOutput
{
    private readonly Config _config;

    public Output(Config config) => _config = config;

    public Task GetSource(ISourceOutputContext ctx)
    {
        Console.WriteLine(config);

        return Task.CompletedTask;
    }
}
```

#### Scopes

A new service scope is created for each new *project*, meaning that outputs for the same project will all get the same scoped services. If you want to create a new service for each call to an output, register it as transient, and as a singleton if you want the same service through every single call.
